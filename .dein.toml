[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'Shougo/vimproc.vim'

[[plugins]]
repo = 'Shougo/denite.nvim'
[[plugins]]
repo = 'Shougo/neosnippet-snippets'

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
  let g:lightline = {
          \ 'colorscheme': 'wombat',
          \ 'mode_map': {'c': 'NORMAL'},
          \ 'active': {
          \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
          \ },
          \ 'component_function': {
          \   'modified': 'LightlineModified',
          \   'readonly': 'LightlineReadonly',
          \   'fugitive': 'LightlineFugitive',
          \   'filename': 'LightlineFilename',
          \   'fileformat': 'LightlineFileformat',
          \   'filetype': 'LightlineFiletype',
          \   'fileencoding': 'LightlineFileencoding',
          \   'mode': 'LightlineMode'
          \ }
          \ }

  function! LightlineModified()
    return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  endfunction

  function! LightlineReadonly()
    return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  endfunction

  function! LightlineFilename()
    return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
          \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
          \  &ft == 'unite' ? unite#get_status_string() :
          \  &ft == 'vimshell' ? vimshell#get_status_string() :
          \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
          \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
  endfunction

  function! LightlineFugitive()
    if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    else
      return ''
    endif
  endfunction

  function! LightlineFileformat()
    return winwidth(0) > 70 ? &fileformat : ''
  endfunction

  function! LightlineFiletype()
    return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
  endfunction

  function! LightlineFileencoding()
    return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
  endfunction

  function! LightlineMode()
    return winwidth(0) > 60 ? lightline#mode() : ''
  endfunction
'''


[[plugins]]
repo = 'Yggdroot/indentLine'

[[plugins]]
repo = 'thinca/vim-quickrun'
hook_add = '''
    " qでバッファ閉じる
    au FileType qf nnoremap <silent><buffer>q :quit<CR>
    
    " 出力バッファへ移動
   
   " \rで書き込んで実行
    let g:quickrun_no_default_key_mappings = 1
    nnoremap \r :write<CR>:QuickRun -mode n<CR>        
    xnoremap \r :<C-U>write<CR>gv:QuickRun -mode v<CR> 
    let g:quickrun_no_default_key_mappings = 1
    nnoremap \r :cclose<CR>:write<CR>:QuickRun -mode n<CR>
    xnoremap \r :<C-U>cclose<CR>:write<CR>gv:QuickRun -mode v<CR>
    
    " C-cで強制終了
    nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"

    let g:quickrun_config = {
        \   "_" : {
            \   "hook/close_buffer/enable_empty_data" : 1,
            \   "outputter/buffer/split" : ":botright 8sp",
            \   "outputter/buffer/into" : 1,
            \   }
        \}
    
    " latexmk
    let g:quickrun_config['tex'] = {
            \   'command' : 'latexmk',
            \   'outputter' : 'error',
            \   'outputter/error/error' : 'quickfix',
            \   'cmdopt': '-pv -pdfdvi',
            \   'exec': ['%c %o %s']
            \ }
'''

# NERDTree
[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add= '''
  nnoremap <silent><C-e> :NERDTreeToggle<CR>
  let NERDTreeMinimalUI=1
'''

[[plugins]]
repo = 'tyru/caw.vim'
hook_add = '''
    nmap \c <Plug>(caw:zeropos:toggle)
    vmap \c <Plug>(caw:zeropos:toggle)
'''
# Colors
[[plugins]]
repo = 'lu-ren/SerialExperimentsLain'

# ts
[[plugins]]
repo = 'leafgarland/typescript-vim'

# processing
[[plugins]]
repo = 'sophacles/vim-processing'

# Clojure
[[plugins]]
repo = 'vim-scripts/VimClojure'

# toml
[[plugins]]
repo = 'cespare/vim-toml'
